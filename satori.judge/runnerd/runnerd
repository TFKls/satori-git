#!/usr/bin/env python3

import cgi
import hashlib
from http.server import HTTPServer, BaseHTTPRequestHandler
import math
import signal
import traceback
from urllib.parse import urlparse, urlencode, parse_qsl
import uuid
import os

RUNNERD_PORT = 8765
RUNNERD_HOST = ''
RUNNERD_SERVERSTRING = 'Runnerd'
RUNNERD_SECRET = uuid.uuid4().hex 
RUNNERD_SECRET = RUNNERD_SERVERSTRING

RUNNERD_CGROUPS = [ 'memory', 'cpuacct', 'cpuset', 'freezer' ]

#TODO: check that cgroups are mounted, and mount them if not?
class Session:
    def cgpath(self, cg, path):
        return os.path.abspath(os.path.join('/sys/fs/cgroup', cg, path.strip('/'), 'runnerd_'+self.id))

    def pidcgs(self, pid):
        with open(os.path.join('/proc', str(pid), 'cgroup')) as f:
            return dict([a.strip().split(':')[1:3] for a in f.readlines()])

    def listcg(self, path):
        result = set()
        for d,_,_ in os.walk(path):
            if os.path.exists(os.path.join(path, d, 'cgroup.procs')):
                with open(os.path.join(path, d, 'cgroup.procs')) as f:
                    result.update([a.strip() for a in f.readlines()])
        return list(result)

    def __init__(self, session_id, pid):
        self.id = session_id
        cgroups = self.pidcgs(pid)
        self.cg = dict()
        for cg in RUNNERD_CGROUPS:
            self.cg[cg] = self.cgpath(cg, cgroups[cg])
        for cg in RUNNERD_CGROUPS:
            if cg == 'memory':
                with open(os.path.normpath(os.path.join(self.cg[cg], '..', 'memory.use_hierarchy')), 'w') as f:
                    f.write('1')
            os.makedirs(self.cg[cg], exist_ok=True)
            if cg == 'cpuset':
                for inherit in ['cpuset.cpus', 'cpuset.mems']:
                    with open(os.path.normpath(os.path.join(self.cg[cg], '..', inherit)), 'r') as f:
                        with open(os.path.join(self.cg[cg], inherit), 'w') as t:
                            t.write(f.read())

    def attach(self, pid):
        cgroups = self.pidcgs(pid)
        for cg in RUNNERD_CGROUPS:
            assert self.cg[cg] == self.cgpath(cg, cgroups[cg])
        for cg in RUNNERD_CGROUPS:
            with open(os.path.join(self.cg[cg], 'tasks'), 'w') as f:
                f.write(str(pid))

    def limit(self, memory, cpus):
        if memory and 'memory' in self.cg:
            with open(os.path.join(self.cg['memory'], 'memory.limit_in_bytes'), 'w') as f:
                f.write(str(memory))
        if cpus and 'cpuset' in self.cg:
            pass #TODO: design cpu limits

    def freeze(self, freeze):
        if freeze:
            freeze = 'FROZEN'
        else:
            freeze = 'THAWED'
        if 'freezer' in self.cg:
            with open(os.path.join(self.cg['freezer'], 'freezer.state'), 'w') as f:
                f.write(freeze)
        #TODO: wait for FROZEN

    def freezing(self):
        if 'freezer' in self.cg:
            with open(os.path.join(self.cg['freezer'], 'freezer.self_freezing')) as f:
                return f.readline().strip() == '1'
        return False

    def query(self):
        result = dict()
        if 'memory' in self.cg:
            with open(os.path.join(self.cg['memory'], 'memory.max_usage_in_bytes'), 'r') as f:
                result['memory'] = f.readline().strip()
        if 'cpuacct' in self.cg:
            with open(os.path.join(self.cg['cpuacct'], 'cpuacct.usage'), 'r') as f:
                result['cpu'] = f.readline().strip()
            with open(os.path.join(self.cg['cpuacct'], 'cpuacct.stat'), 'r') as f:
                _, result['cpu.user'] = f.readline().strip().split()
                _, result['cpu.system'] = f.readline().strip().split()
            with open(os.path.join(self.cg['cpuacct'], 'cpuacct.usage_percpu'), 'r') as f:
                cpusplit = f.readline().strip().split()
            for i,c in zip(range(len(cpusplit)), cpusplit):
                result['cpu.'+str(i)] = c
            result['procs'] = str(len(self.listcg(self.cg['cpuacct'])))
        return result

    def kill(self):
        state = self.freezing()
        self.freeze(True)

        pids = self.listcg(self.cg['cpuacct'])
        for pid in pids:
            try:
                os.kill(int(pid), signal.SIGKILL)
            except OSError:
                pass

        self.freeze(state)

    def close(self):
        state = self.freezing()
        self.freeze(True)

        for cg in sorted(RUNNERD_CGROUPS, key=lambda x: 1 if x == 'freezer' else 0):
            dest = os.path.normpath(os.path.join(self.cg[cg], '..', 'tasks'))
            for d,_,_ in os.walk(self.cg[cg], topdown=False):
                if os.path.exists(os.path.join(self.cg[cg], d, 'cgroup.procs')):
                    with open(dest, 'w') as t:
                        with open(os.path.join(self.cg[cg], d, 'cgroup.procs')) as f:
                            t.write(f.read())
                os.rmdir(os.path.join(self.cg[cg], d))
            

class Registry:
    def __init__(self):
        self.sessions = dict()

    def __del__(self):
        self.cleanup()

    def cleanup(self):
        for session_id in dict(self.sessions):
            self.close_cg(session_id)

    def open_cg(self, session_id, pid):
        if session_id not in self.sessions:
            self.sessions[session_id] = Session(session_id, pid)
        return self.sessions[session_id].attach(pid);

    def limit_cg(self, session_id, memory, cpus):
        assert session_id in self.sessions
        return self.sessions[session_id].limit(memory, cpus)

    def query_cg(self, session_id):
        assert session_id in self.sessions
        return self.sessions[session_id].query()

    def freeze_cg(self, session_id):
        assert session_id in self.sessions
        return self.sessions[session_id].freeze(True)

    def thaw_cg(self, session_id):
        assert session_id in self.sessions
        return self.sessions[session_id].freeze(False)

    def kill_cg(self, session_id):
        if session_id not in self.sessions:
            return
        self.sessions[session_id].kill()

    def close_cg(self, session_id):
        if session_id not in self.sessions:
            return
        self.sessions[session_id].close()
        del self.sessions[session_id]

RUNNERD_REGISTRY = Registry()

class HTTPHandler(BaseHTTPRequestHandler):
    def do_HEAD(self):
        self.send_response(200)
        self.send_header('Server', RUNNERD_SERVERSTRING)
        self.end_headers()
    def do_POST(self):
        try:
            post_data = dict()
            if 'Content-Length' in self.headers:
                post_length   = int(self.headers['Content-Length'])
                if 'Content-Type' in self.headers:
                    post_type, post_type_dict  = cgi.parse_header(self.headers['Content-Type'])
                    post_charset = post_type_dict.get('charset', 'utf-8')
                    if post_type == 'application/x-www-form-urlencoded':
                        post_data = dict(parse_qsl(self.rfile.read(post_length).decode(post_charset)))
        except:
            self.send_error(400)
            return
        else:
            return self.do_GET(params_override=post_data)
    def do_GET(self, params_override={}):
        try:
            url = urlparse(self.path)
            path = url.path.strip('/ ').lower()
            params = dict(parse_qsl(url.query))
            params.update(params_override)
        except:
            self.send_error(400)
            return
        else:
            return self.cmd(path, params)

    def cmd(self, path, params):
        check_session = False
        fun = self.cmd_default
        if path == '':
            fun = self.cmd_root
        elif path == 'open':
            fun = self.cmd_open
            check_session = True
        elif path == 'limit':
            fun = self.cmd_limit
            check_session = True
        elif path == 'freeze':
            fun = self.cmd_freeze
            check_session = True
        elif path == 'thaw':
            fun = self.cmd_thaw
            check_session = True
        elif path == 'query':
            if not params.get('session_id', ''):
                self.send_error(400)
                return
            fun = self.cmd_query
        elif path == 'kill':
            fun = self.cmd_kill
            check_session = True
        elif path == 'close':
            fun = self.cmd_close
            check_session = True

        if check_session:
            if not self.check_secret(params.get('session_id', ''), params.get('secret', '')):
                self.send_error(403)
                return
        try:
            result = urlencode(fun(params))
        except:
            traceback.print_exc()
            self.send_error(500)
            return
        else:
            self.send_response(200)
            self.send_header('Server', RUNNERD_SERVERSTRING)
            self.send_header('Content-Type', 'application/x-www-form-urlencoded; charset=utf-8')
            self.send_header('Content-Length', len(result))
            self.end_headers()
            self.wfile.write(bytes(result, 'utf-8'))

    def cmd_default(self, params):
        result = dict()
        result['result'] = 'FAIL'
        result['message'] = 'method unknown'
        return result

    def cmd_root(self, params):
        result = dict()
        result['result'] = 'OK'
        result['session_id'] = self.generate_session_id()
        result['secret'] = self.generate_secret(result['session_id'])
        return result

    def cmd_open(self, params):
        result = dict()
        filename = params.get('file', '')
        prefix = 'runner_'+params['session_id']
        if not filename.startswith(prefix):
            result['result'] = 'FAIL'
            result['message'] = 'Filename must start with ' + prefix
            return result
        pid = self.find_pid(filename)
        if pid == None:
            result['result'] = 'FAIL'
            result['message'] = 'Process not found'
            return result
        else:
            RUNNERD_REGISTRY.open_cg(params['session_id'], pid)
            result['result'] = 'OK'
            result['pid'] = str(pid)
            return result

    def cmd_limit(self, params):
        result = dict()
        memory = self.parse_memory(params.get('memory', ''))
        cpus = self.parse_cpus(params.get('cpus', ''))
        RUNNERD_REGISTRY.limit_cg(params['session_id'], memory, cpus)
        result['result'] = 'OK'
        return result

    def cmd_query(self, params):
        result = dict()
        result.update(RUNNERD_REGISTRY.query_cg(params['session_id']))
        result['result'] = 'OK'
        return result

    def cmd_kill(self, params):
        result = dict()
        RUNNERD_REGISTRY.kill_cg(params['session_id'])
        result['result'] = 'OK'
        return result

    def cmd_close(self, params):
        result = dict()
        RUNNERD_REGISTRY.close_cg(params['session_id'])
        result['result'] = 'OK'
        return result

    def generate_session_id(self):
        return uuid.uuid4().hex

    def generate_secret(self, session_id):
        return hashlib.sha1(bytes(RUNNERD_SECRET+session_id, 'utf-8')).hexdigest()

    def check_secret(self, session_id, secret):
        return secret and session_id and secret == self.generate_secret(session_id)

    def find_pid(self, filename):
        name = os.path.basename(filename)
        for pid in os.listdir('/proc'):
            try:
                for fd in os.listdir(os.path.join('/proc', pid, 'fd')):
                    path = os.path.basename(os.path.realpath(os.path.join('/proc', pid, 'fd', fd)))
                    if path == name:
                        return pid
            except:
                pass
        return None

    def parse_memory(self, memory):
        mul = 1
        memstr = memory.strip().lower()
        if memstr[-1] == 'b':
            mul = 1
            memstr = memstr[:-1]
        if memstr[-1] == 'k':
            mul = 1024
            memstr = memstr[:-1]
        elif memstr[-1] == 'm':
            mul = 1024**2
            memstr = memstr[:-1]
        elif memstr[-1] == 'g':
            mul = 1024**3
            memstr = memstr[:-1]
        elif memstr[-1] == 't':
            mul = 1024**4
            memstr = memstr[:-1]
        elif memstr[-1] == 'p':
            mul = 1024**5
            memstr = memstr[:-1]
        return int(math.ceil(float(memstr) * mul))

    def parse_cpus(self, cpus):
        pass #TODO: design cpu limiting

def run():
    httpd = HTTPServer((RUNNERD_HOST, RUNNERD_PORT), HTTPHandler)
    httpd.serve_forever()

run()
